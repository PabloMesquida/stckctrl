/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 box.glb --shadows
*/

import React, { useState, useRef, useEffect } from "react";
import * as THREE from "three";
import { useGLTF } from "@react-three/drei";
import { RigidBody, CuboidCollider, Debug } from "@react-three/rapier";
import { useFrame } from "@react-three/fiber";

export default function Model({ type, setIsAreaActive, setIsLightActive }) {
  const [active, setActive] = useState(true);
  const [spin, setSpin] = useState(false);
  const [lightControl, setLightControl] = useState(false);

  const { nodes, materials } = useGLTF("/models/box.glb");

  const body = useRef();

  const impulseForce = 28; // 0.45
  const center = 0.32;

  useEffect(() => {
    if (spin) {
      let area;
      switch (type) {
        case 0:
          area = "square";
          break;
        case 1:
          area = "circle";
          break;
        case 2:
          area = "triangle";
          break;
        default:
          area = null;
      }
      if (area) {
        setIsAreaActive((prev) => ({ ...prev, [area]: true }));
        const timer = setTimeout(() => {
          body.current.setTranslation([0, -500, 0]); // Remove Rigidbody ?
          setIsAreaActive((prev) => ({ ...prev, [area]: false }));
          setActive(false);
        }, 4000);
        return () => clearTimeout(timer);
      }
    }
  }, [spin]);

  useEffect(() => {
    let light;
    switch (type) {
      case 0:
        light = "square";
        break;
      case 1:
        light = "circle";
        break;
      case 2:
        light = "triangle";
        break;
      default:
        light = null;
    }
    if (light) {
      setIsLightActive((prev) => ({ ...prev, [light]: true }));
      const timer = setTimeout(() => {
        setIsLightActive((prev) => ({ ...prev, [light]: false }));
      }, 1000);
      return () => clearTimeout(timer);
    }
  }, [lightControl]);

  useFrame((state, delta) => {
    const bodyPosition = body.current.translation();

    if (bodyPosition.z < 1.5 && bodyPosition.z > center) {
      //  console.log("TRUE");
      setLightControl(true);
    } else {
      // console.log("FALSE");
      setLightControl(false);
    }

    // console.log(bodyPosition.z);
    if (bodyPosition.y < 0.08) {
      if (bodyPosition.z > center) {
        body.current.applyImpulse({ x: 0, y: 0, z: -impulseForce * delta });
      } else {
        switch (type) {
          case 0:
            body.current.applyImpulse({
              x: 0,
              y: 0,
              z: -impulseForce * delta,
            });
            break;
          case 1:
            body.current.applyImpulse({
              x: impulseForce * delta,
              y: 0,
              z: 0,
            });
            break;
          case 2:
            body.current.applyImpulse({
              x: -impulseForce * delta,
              y: 0,
              z: 0,
            });
            break;
        }
      }
    }

    if (Math.abs(bodyPosition.x) > 1.9 || bodyPosition.z < -1.9) setSpin(true);
  });

  return (
    <>
      <group visible={active} dispose={null}>
        <RigidBody
          position={[0, 5, 9]}
          rotation={[0, -Math.PI / 2, 0]}
          ref={body}
          mass={1}
          restitution={0}
        >
          <group dispose={null}>
            <mesh
              visible={type === 0}
              castShadow
              receiveShadow
              geometry={nodes.Simbol_01.geometry}
              //   material={materials.SimbolMaterial01}
              scale={[0.45, 0.45, 1.05]}
            >
              <meshStandardMaterial
                color={"green"}
                emissive={"green"}
                emissiveIntensity={"0"}
              />
            </mesh>

            <mesh
              visible={type === 1}
              castShadow
              receiveShadow
              geometry={nodes.Simbol_02.geometry}
              //material={materials.SimbolMaterial02}
              rotation={[Math.PI / 2, 0, 0]}
              scale={[0.45, 1.05, 0.45]}
            >
              <meshStandardMaterial
                color={"yellow"}
                emissive={"yellow"}
                emissiveIntensity={"0"}
              />
            </mesh>

            <mesh
              visible={type === 2}
              castShadow
              receiveShadow
              geometry={nodes.Simbol_03.geometry}
              //  material={materials.SimbolMaterial03}
              rotation={[Math.PI / 2, 0, 0]}
              scale={[0.5, 1.05, 0.5]}
            >
              <meshStandardMaterial
                color={"purple"}
                emissive={"purple"}
                emissiveIntensity={"0"}
              />
            </mesh>

            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube.geometry}
              material={materials.BoxMaterial}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube_1.geometry}
              material={materials.LabelMaterial}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube_2.geometry}
              material={materials.ZipMaterial}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube_3.geometry}
              material={materials.CornerMaterial}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube_4.geometry}
              material={materials.InfoMaterial}
            />
            <CuboidCollider
              args={[0.5, 0.5, 0.5]}
              restitution={0}
              friction={0.1}
            />
          </group>
        </RigidBody>
      </group>
    </>
  );
}
