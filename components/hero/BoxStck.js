/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 box.glb --shadows
*/

import React, { useState, useRef, useEffect } from "react";
import * as THREE from "three";
import { useGLTF } from "@react-three/drei";
import { RigidBody, CuboidCollider, Debug } from "@react-three/rapier";
import { useFrame } from "@react-three/fiber";

export default function Model({ type }) {
  const [active, setActive] = useState(true);
  const [spin, setSpin] = useState(false);

  const { nodes, materials } = useGLTF("/models/box.glb");

  const body = useRef();

  const impulseForce = 0.45;
  const center = 0.32;

  useEffect(() => {
    if (spin) {
      const timer = setTimeout(() => {
        body.current.setTranslation([0, -500, 0]); // Remove Rigidbody ?
        setActive(false);
      }, 4000);
      return () => clearTimeout(timer);
    }
  }, [spin]);

  const rotation = new THREE.Quaternion();

  useFrame((state) => {
    const bodyPosition = body.current.translation();

    if (bodyPosition.y < 0.08) {
      if (bodyPosition.z > center) {
        body.current.applyImpulse({ x: 0, y: 0, z: -impulseForce });
      } else {
        switch (type) {
          case 0:
            body.current.applyImpulse({ x: 0, y: 0, z: -impulseForce });
            break;
          case 1:
            body.current.applyImpulse({ x: impulseForce, y: 0, z: 0 });
            break;
          case 2:
            body.current.applyImpulse({ x: -impulseForce, y: 0, z: 0 });
            break;
        }
      }
    }

    if (Math.abs(bodyPosition.x) > 1.9 || bodyPosition.z < -1.9) setSpin(true);

    if (spin) {
      const time = state.clock.getElapsedTime();

      rotation.setFromEuler(new THREE.Euler(0, time * 2, 0));

      body.current.setNextKinematicRotation(rotation);
      // body.current.setRotation(rotation);
    }
  });

  return (
    <>
      <group visible={active} dispose={null}>
        <RigidBody
          position={[0, 10, 9]}
          rotation={[0, -Math.PI / 2, 0]}
          ref={body}
          mass={1}
          restitution={0}
        >
          <group dispose={null}>
            <mesh
              visible={type === 0}
              castShadow
              receiveShadow
              geometry={nodes.Simbol_01.geometry}
              material={materials.SimbolMaterial01}
              scale={[0.45, 0.45, 1.05]}
            />

            <mesh
              visible={type === 1}
              castShadow
              receiveShadow
              geometry={nodes.Simbol_02.geometry}
              material={materials.SimbolMaterial02}
              rotation={[Math.PI / 2, 0, 0]}
              scale={[0.45, 1.05, 0.45]}
            />

            <mesh
              visible={type === 2}
              castShadow
              receiveShadow
              geometry={nodes.Simbol_03.geometry}
              material={materials.SimbolMaterial03}
              rotation={[Math.PI / 2, 0, 0]}
              scale={[0.5, 1.05, 0.5]}
            />

            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube.geometry}
              material={materials.BoxMaterial}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube_1.geometry}
              material={materials.LabelMaterial}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube_2.geometry}
              material={materials.ZipMaterial}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube_3.geometry}
              material={materials.CornerMaterial}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Cube_4.geometry}
              material={materials.InfoMaterial}
            />
            <CuboidCollider
              args={[0.5, 0.5, 0.5]}
              restitution={0}
              friction={0.1}
            />
          </group>
        </RigidBody>
      </group>
    </>
  );
}
